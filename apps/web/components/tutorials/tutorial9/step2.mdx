Let's examine the counter account contract.

**No-std Environment**

```rust
#![no_std]
```

Miden contracts run in a **`no_std`** environment, meaning they don't link against Rust's standard library. This is essential for blockchain execution where contracts need to be deterministic and lightweight.

**Miden Library Imports**

```rust
use miden::{
  component, felt, Felt, StorageMap, StorageMapAccess, Word
};
```

These imports provide:

- **`component`**: Macro for defining contract components
- **`Felt`**/**`Word`**: Miden's native field element and word types
- **`StorageMap`**: Key-value storage within account storage slots
- **`StorageMapAccess`**: Needed for reading storage values (**`get_count`** function)

**Contract Structure Definition**

```rust
#[component]
struct CounterContract {
    /// Storage map holding the counter value.
    #[storage(slot(0), description = "...")]
    count_map: StorageMap,
}
```

The **`#[component]`** attribute marks this as a Miden component.
The **`count_map`** field is a **`StorageMap`** that will be stored in storage slot 0 of the account.

**Important**: Storage slots in Miden hold **`Word`** values, which are composed of four field elements (**`Felt`**).
Each **`Felt`** is a 64-bit unsigned integer (u64).
The **`StorageMap`** provides a key-value interface within a single storage slot, allowing you to store multiple key-value pairs within the four-element word structure.

**Contract Implementation**

```rust
impl CounterContract {
    // Function implementations...
}
```

The **`CounterContract`** implementation defines the external interface that other contracts and notes can call. This is the contract's public API.

**Storage Key Strategy**

```rust
let key = Word::from([felt!(0), felt!(0), felt!(0), felt!(1)]);
```

Both functions use the same fixed key **`[0, 0, 0, 1]`** to store and retrieve the counter value within the storage map. This demonstrates a simple but effective storage pattern.
